프로젝트 구조 (2025 3월 14일 버전 간혹가다 업데이트 하겟음)
ssy@ssy-MS-7E01:~/git/homeegui/src$ tree
.
├── Backend
│   ├── Backend.rs
│   └── mod.rs
├── Frontend
│   ├── Pages
│   │   ├── dashboard.rs
│   │   ├── icon
│   │   │   ├── Forward.svg
│   │   │   ├── Play Arrow.svg
│   │   │   ├── Skip Next.svg
│   │   │   ├── Skip Previous.svg
│   │   │   ├── Stop_music.svg
│   │   │   ├── avi.svg
│   │   │   ├── back.svg
│   │   │   ├── bell.svg
│   │   │   ├── bell2.svg
│   │   │   ├── cloud with bk.svg
│   │   │   ├── controlbar.svg
│   │   │   ├── database.svg
│   │   │   ├── database3.svg
│   │   │   ├── databasewithbackground.svg
│   │   │   ├── doc.svg
│   │   │   ├── file with background.svg
│   │   │   ├── file.svg
│   │   │   ├── file2.svg
│   │   │   ├── folder.svg
│   │   │   ├── folder2.svg
│   │   │   ├── home.svg
│   │   │   ├── lock.svg
│   │   │   ├── mail.svg
│   │   │   ├── many peoples.svg
│   │   │   ├── musicfile.svg
│   │   │   ├── peoples.svg
│   │   │   ├── plus.svg
│   │   │   ├── setting.svg
│   │   │   ├── zip.svg
│   │   │   ├── 돋보기.svg
│   │   │   ├── 모래시계.svg
│   │   │   ├── 물음표.svg
│   │   │   └── 확성기.svg
│   │   ├── login.rs
│   │   └── mod.rs
│   ├── Utility
│   │   ├── icon
│   │   │   ├── Forward.svg
│   │   │   ├── Play Arrow.svg
│   │   │   ├── Skip Next.svg
│   │   │   ├── Skip Previous.svg
│   │   │   ├── Stop_music.svg
│   │   │   ├── avi.svg
│   │   │   ├── back.svg
│   │   │   ├── bell.svg
│   │   │   ├── bell2.svg
│   │   │   ├── cloud with bk.svg
│   │   │   ├── controlbar.svg
│   │   │   ├── database.svg
│   │   │   ├── database3.svg
│   │   │   ├── databasewithbackground.svg
│   │   │   ├── doc.svg
│   │   │   ├── docker.svg
│   │   │   ├── file with background.svg
│   │   │   ├── file.svg
│   │   │   ├── file2.svg
│   │   │   ├── folder.svg
│   │   │   ├── folder2.svg
│   │   │   ├── home.svg
│   │   │   ├── hourglass.svg
│   │   │   ├── lock.svg
│   │   │   ├── mail.svg
│   │   │   ├── many peoples.svg
│   │   │   ├── musicfile.svg
│   │   │   ├── peoples.svg
│   │   │   ├── plus.svg
│   │   │   ├── question.svg
│   │   │   ├── reading_glasses.svg
│   │   │   ├── setting.svg
│   │   │   ├── speaker.svg
│   │   │   └── zip.svg
│   │   ├── icon_loader.rs
│   │   ├── mod.rs
│   │   └── ui_styles.rs
│   ├── app.rs
│   ├── main.rs
│   └── mod.rs
└── main.rs


소스코드
[icon_loader.rs]
use Rusty_egui::egui;
use usvg;
use resvg;
use egui::ColorImage;
use Rusty_egui::image::{ImageBuffer, Rgba};
use tiny_skia;
use std::collections::HashMap;
use crate::Frontend::Utility::ui_styles::{UiStyle,ContextStyle};
use std::rc::Rc;
use std::cell::RefCell;






#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Icon {
    SKIP_NEXT,
    CLOUD_WITH_BK,
    FILE,
    DATABASE,
    DOC,
    STOP_MUSIC,
    DATABASE3,
    SPEAKER,
    FOLDER2,
    PEOPLES,
    DATABASEWITHBACKGROUND,
    FOLDER,
    SETTING,
    READING_GLASSES,
    FILE_WITH_BACKGROUND,
    AVI,
    MANY_PEOPLES,
    SKIP_PREVIOUS,
    HOME,
    PLUS,
    BELL,
    LOCK,
    PLAY_ARROW,
    BACK,
    FORWARD,
    CONTROLBAR,
    ZIP,
    MAIL,
    MUSICFILE,
    HOURGLASS,
    QUESTION,
    BELL2,
    FILE2,
    DOCKER,
}

const skip_next : &[u8]= include_bytes!("icon/Skip Next.svg");
const cloud_with_bk : &[u8]= include_bytes!("icon/cloud with bk.svg");
const file : &[u8]= include_bytes!("icon/file.svg");
const database : &[u8]= include_bytes!("icon/database.svg");
const doc : &[u8]= include_bytes!("icon/doc.svg");
const stop_music : &[u8]= include_bytes!("icon/Stop_music.svg");
const database3 : &[u8]= include_bytes!("icon/database3.svg");
const speaker : &[u8]= include_bytes!("icon/speaker.svg");
const folder2 : &[u8]= include_bytes!("icon/folder2.svg");
const peoples : &[u8]= include_bytes!("icon/peoples.svg");
const databasewithbackground : &[u8]= include_bytes!("icon/databasewithbackground.svg");
const folder : &[u8]= include_bytes!("icon/folder.svg");
const setting : &[u8]= include_bytes!("icon/setting.svg");
const reading_glasses : &[u8]= include_bytes!("icon/reading_glasses.svg");
const file_with_background : &[u8]= include_bytes!("icon/file with background.svg");
const avi : &[u8]= include_bytes!("icon/avi.svg");
const many_peoples : &[u8]= include_bytes!("icon/many peoples.svg");
const skip_previous : &[u8]= include_bytes!("icon/Skip Previous.svg");
const home : &[u8]= include_bytes!("icon/home.svg");
const plus : &[u8]= include_bytes!("icon/plus.svg");
const bell : &[u8]= include_bytes!("icon/bell.svg");
const lock : &[u8]= include_bytes!("icon/lock.svg");
const play_arrow : &[u8]= include_bytes!("icon/Play Arrow.svg");
const back : &[u8]= include_bytes!("icon/back.svg");
const forward : &[u8]= include_bytes!("icon/Forward.svg");
const controlbar : &[u8]= include_bytes!("icon/controlbar.svg");
const zip : &[u8]= include_bytes!("icon/zip.svg");
const mail : &[u8]= include_bytes!("icon/mail.svg");
const musicfile : &[u8]= include_bytes!("icon/musicfile.svg");
const hourglass : &[u8]= include_bytes!("icon/hourglass.svg");
const question : &[u8]= include_bytes!("icon/question.svg");
const bell2 : &[u8]= include_bytes!("icon/bell2.svg");
const file2 : &[u8]= include_bytes!("icon/file2.svg");
const docker : &[u8]= include_bytes!("icon/docker.svg");

impl Icon {
    pub fn data(&self) -> &'static [u8] {
        match self {
            Icon::SKIP_NEXT => skip_next,
            Icon::CLOUD_WITH_BK => cloud_with_bk,
            Icon::FILE => file,
            Icon::DATABASE => database,
            Icon::DOC => doc,
            Icon::STOP_MUSIC => stop_music,
            Icon::DATABASE3 => database3,
            Icon::SPEAKER => speaker,
            Icon::FOLDER2 => folder2,
            Icon::PEOPLES => peoples,
            Icon::DATABASEWITHBACKGROUND => databasewithbackground,
            Icon::FOLDER => folder,
            Icon::SETTING => setting,
            Icon::READING_GLASSES => reading_glasses,
            Icon::FILE_WITH_BACKGROUND => file_with_background,
            Icon::AVI => avi,
            Icon::MANY_PEOPLES => many_peoples,
            Icon::SKIP_PREVIOUS => skip_previous,
            Icon::HOME => home,
            Icon::PLUS => plus,
            Icon::BELL => bell,
            Icon::LOCK => lock,
            Icon::PLAY_ARROW => play_arrow,
            Icon::BACK => back,
            Icon::FORWARD => forward,
            Icon::CONTROLBAR => controlbar,
            Icon::ZIP => zip,
            Icon::MAIL => mail,
            Icon::MUSICFILE => musicfile,
            Icon::HOURGLASS => hourglass,
            Icon::QUESTION => question,
            Icon::BELL2 => bell2,
            Icon::FILE2 => file2,
            Icon::DOCKER => docker,
        }
    }
}


fn apply_interactive_styles(
    cpdata:IconButton,ui: &mut egui::Ui, response: &egui::Response
) {
        // 상태에 따라 적절한 배경색 선택
        // 상태에 따라 적절한 배경색 선택

        let background_color = if response.clicked() {
            // 클릭 스타일 
            cpdata.click_style.map_or(egui::Color32::from_rgb(37, 99, 235), |s| s.accent)
        } else if response.hovered() {
            if matches!(cpdata.style, ButtonStyle::Explorer) {
                return;
            }
            // 호버 스타일
            cpdata.hover_style.map_or(egui::Color32::from_rgb(80, 140, 230), |s| s.hover)


        } else {
            return; // 호버나 클릭 상태가 아니면 아무것도 하지 않음
        };

        // 배경 다시 그리기
        ui.painter().rect_filled(
            response.rect,
            egui::Rounding::same(2.0), // 약간의 라운딩
            background_color
        );
        
        // 필요시 아이콘 다시 그리기 (호버/클릭 시 아이콘 색상도 변경하려면)
        if cpdata.tint.is_some() || response.hovered() || response.clicked() {
            let icon_pos = egui::pos2(
                response.rect.min.x + 10.0,
                response.rect.center().y - cpdata.size.y / 2.0
            );
            
            let tint = if response.clicked() && cpdata.click_style.is_some() {
                cpdata.click_style.map_or(egui::Color32::WHITE, |s| s.text)
            } else if response.hovered() && cpdata.hover_style.is_some() {
                cpdata.hover_style.map_or(egui::Color32::WHITE, |s| s.text)
            } else {
                cpdata.tint.unwrap_or(egui::Color32::WHITE)
            };
            
            ui.painter().image(
                cpdata.texture.id(),
                egui::Rect::from_min_size(icon_pos, cpdata.size),
                egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(1.0, 1.0)),
                tint
            );
        }
    }
    


fn load_svg_icon(ctx: &egui::Context, svg_bytes: &[u8]) -> egui::TextureHandle {
    // SVG를 ColorImage로 변환
    let image = load_svg_as_color_image(svg_bytes);
    
    // ColorImage는 ImageData로 변환 가능
    ctx.load_texture(
        "icon",
        image,
        egui::TextureOptions::default()
    )
}
fn _debug_save_color_image_as_png(color_image: &ColorImage, path: &str) {
    let width = color_image.width();
    let height = color_image.height();

    let mut img_buf = ImageBuffer::new(width as u32, height as u32);

    for y in 0..height {
        for x in 0..width {
            // ColorImage는 (r, g, b, a) 각 8비트
            let c = color_image[(x, y)];
            let pixel = Rgba([c.r(), c.g(), c.b(), c.a()]);
            img_buf.put_pixel(x as u32, y as u32, pixel);
        }
    }

    // 실제로 PNG로 저장
    img_buf
        .save(path)
        .unwrap_or_else(|e| eprintln!("PNG 파일 저장 실패: {}", e));
}


fn load_svg_as_color_image(svg_bytes: &[u8]) -> egui::ColorImage {
    use usvg::{Tree, Options};
    use resvg;

    let options = Options::default();
    let rtree = Tree::from_data(svg_bytes, &options).expect("SVG 파싱 실패");

    let pixmap_size = rtree.size().to_int_size();
    let (w, h) = (pixmap_size.width() as u32, pixmap_size.height() as u32);

    let mut pixmap = tiny_skia::Pixmap::new(w, h).unwrap();

    // pixmap.as_mut() : Option<PixmapMut<'_>>
    // 잘못된 예 (직접 as_mut() 결과를 넣거나...)
    resvg::render(&rtree, tiny_skia::Transform::default(),&mut pixmap.as_mut());
    // ↑ 여기서 타입 불일치: 
    //   expected `&mut PixmapMut`, found `Option<PixmapMut>`

    let rgba_data = pixmap.data();
    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], rgba_data)
}


pub struct IconLoader {
    icons: egui::TextureHandle,
    data : &'static [u8],
    ctx: egui::Context,
}

impl IconLoader {
    pub fn new(ctx: & egui::Context,icon_type:Icon) -> Self {
        let data =icon_type.data();
        let icons = load_svg_icon(ctx, data);
        Self {
            icons,
            data,
            ctx: ctx.clone(),
        }
    }
    fn load_icon(&mut self, icon_type: Icon) {
        self.data = icon_type.data();
        self.icons = load_svg_icon(&self.ctx, self.data);
    }
}
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum ButtonStyle {
    Plain,     // 프레임 없음
    Framed,    // 프레임 있음
    Menu,      // 메뉴 항목 스타일
    Primary,   // 주요 액션 버튼
    Secondary, // 보조 액션 버튼
    Explorer,
    // 필요한 다른 스타일들...
}
#[derive(Clone)]
pub struct IconButton {
    icon: Icon,
    texture: egui::TextureHandle,
    style: ButtonStyle,
    size: egui::Vec2,
    tint: Option<egui::Color32>,
    selected: bool,
    tooltip: Option<String>,
    // 상태별 스타일 추가
    default_style: Option<UiStyle>,
    hover_style: Option<UiStyle>,
    click_style: Option<UiStyle>,
    id:usize,
}

impl IconButton {
    pub fn new(ctx: &egui::Context, icon: Icon, button_style: ButtonStyle) -> Self {
        let size = match button_style {
            ButtonStyle::Menu => egui::vec2(16.0, 16.0),
            _ => egui::vec2(20.0, 20.0),
        };
        
        let texture = load_svg_icon(ctx, icon.data());
        
        Self {
            icon,
            texture,
            style: button_style,
            size,
            tint: None,
            selected: false,
            tooltip: None,
            default_style: None,
            hover_style: None,
            click_style: None,
            id:0,
        }
    }
    
    // 기존 메서드들...
    
    // 상태별 스타일 설정 메서드 추가
    pub fn with_style(mut self, style: &UiStyle) -> Self {
        self.default_style = Some(*style);
        self
    }
    
    pub fn with_hover_style(mut self, style: &UiStyle) -> Self {
        self.hover_style = Some(*style);
        self
    }
    
    pub fn with_click_style(mut self, style: &UiStyle) -> Self {
        self.click_style = Some(*style);
        self
    }
    
    pub fn show(self, ui: &mut egui::Ui) -> egui::Response {
        let mut response = match self.style {
            ButtonStyle::Plain | ButtonStyle::Framed => {
                // 이미지 버튼 처리
                let mut button = egui::ImageButton::new(
                    egui::load::SizedTexture::new(self.texture.id(), self.size)
                ).frame(self.style == ButtonStyle::Framed);
                
                if let Some(tint) = self.tint {
                    button = button.tint(tint);
                }
                
                ui.add(button)
            },
            ButtonStyle::Explorer => {
                let text = match &self.tooltip {
                    Some(text) => {
                       //println!("{}", text);
                        text.as_str()
                    },
                    None => {
                        //println!("No tooltip");
                        "No tooltip"
                    }
                };
            
                let (rect, response) = ui.allocate_at_least(self.size, egui::Sense::click());
            
                // 배경 투명
                // ui.painter().rect_filled(rect, 0.0, egui::Color32::TRANSPARENT);
            
                // 아이콘 그리기
                let icon_pos = egui::pos2(
                    rect.center().x - (self.size.x * 0.5),
                    rect.center().y - (self.size.y * 0.5),
                );
                ui.painter().image(
                    self.texture.id(),
                    egui::Rect::from_min_size(icon_pos, self.size),
                    egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(1.0, 1.0)),
                    egui::Color32::WHITE,
                );
            
                // ★추가★ 텍스트(파일명) 표시:
                //    아이콘 아래 / 위 원하는 곳에 그리기
                let text_pos = egui::pos2(
                    rect.center().x - 20.0,
                    rect.center().y + (self.size.y * 0.4), // 아이콘 하단 아래쪽
                );
                ui.painter().text(
                    text_pos,
                    egui::Align2::LEFT_TOP,
                    text,
                    egui::FontId::proportional(14.0),
                    egui::Color32::WHITE,
                );
            
                if response.clicked() {
                    println!("Explorer style icon clicked: {}", text);
                }
            
                response
            }
            ButtonStyle::Menu => {
                // 기본 스타일 적용 (제공된 경우)
                let mut visuals = ui.style().visuals.clone();
                if let Some(default_style) = &self.default_style {
                    visuals.widgets.inactive.bg_fill = default_style.background;
                    visuals.widgets.inactive.fg_stroke = egui::Stroke::new(1.0, default_style.text);
                    visuals.widgets.inactive.bg_stroke = egui::Stroke::new(1.0, default_style.border);
                    
                    visuals.widgets.hovered.bg_fill = default_style.hover;
                    visuals.widgets.hovered.fg_stroke = egui::Stroke::new(1.0, default_style.text);
                    visuals.widgets.hovered.bg_stroke = egui::Stroke::new(1.0, default_style.border);
                    
                    visuals.widgets.active.bg_fill = default_style.accent;
                    visuals.widgets.active.fg_stroke = egui::Stroke::new(1.0, default_style.text);
                    visuals.widgets.active.bg_stroke = egui::Stroke::new(1.0, default_style.border);
                }
                
                // 호버 스타일이 제공된 경우 오버라이드
                if let Some(hover_style) = &self.hover_style {
                    //visuals.widgets.hovered.bg_fill = hover_style.background;
                    visuals.widgets.hovered.bg_fill = hover_style.hover;
                    visuals.widgets.hovered.fg_stroke = egui::Stroke::new(1.0, hover_style.text);//default_style
                    visuals.widgets.hovered.bg_stroke = egui::Stroke::new(1.0, hover_style.border);
                }
                
                // 클릭 스타일이 제공된 경우 오버라이드
                if let Some(click_style) = &self.click_style {
                    //visuals.widgets.active.bg_fill = click_style.background;
                    visuals.widgets.active.bg_fill = click_style.accent;
                    visuals.widgets.active.fg_stroke = egui::Stroke::new(1.0, click_style.text);
                    visuals.widgets.active.bg_stroke = egui::Stroke::new(1.0, click_style.border);
                }
                
                let old_visuals = ui.style().visuals.clone();
                ui.style_mut().visuals = visuals.clone();
                
                let button = egui::Button::new({
                let text = match &self.tooltip {
                    Some(text) => {
                           //println!("{}", text);
                            text.as_str() // 또는 &text[..]
                    },
                    None => {
                            //println!("No tooltip");
                            "No tooltip"
                    }
                    };
                    let mut rich_text = egui::RichText::new(text);
                    if self.selected {
                        rich_text = rich_text.strong();
                    }
                    rich_text
                })
                .fill(if self.selected {
                    self.default_style.map_or(egui::Color32::from_rgb(45, 55, 65), |s| s.selected)
                } else {
                    self.default_style.map_or(egui::Color32::TRANSPARENT, |s| s.background)
                })
                .frame(true);
                
                let response = ui.add_sized([ui.available_width(), 32.0], button);
                
                // 아이콘 그리기
                let rect = response.rect;
                let icon_pos = egui::pos2(
                    rect.min.x + 10.0,
                    rect.center().y - self.size.y / 2.0
                );
                
                ui.painter().image(
                    self.texture.id(),
                    egui::Rect::from_min_size(icon_pos, self.size),
                    egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(1.0, 1.0)),
                    self.tint.unwrap_or(egui::Color32::WHITE)
                );
                
                // 선택된 항목의 왼쪽에 표시기 추가
                if self.selected {
                    let indicator_width = 3.0;
                    let accent_color = self.default_style.map_or(
                        egui::Color32::from_rgb(59, 130, 246), 
                        |s| s.accent
                    );
                    
                    let indicator_rect = egui::Rect::from_min_size(
                        egui::pos2(rect.min.x, rect.min.y),
                        egui::vec2(indicator_width, rect.height())
                    );
                    ui.painter().rect_filled(
                        indicator_rect,
                        0.0,
                        accent_color
                    );
                }
                
                // 원래 스타일로 복원
                ui.style_mut().visuals = old_visuals;
                apply_interactive_styles(self.clone(),ui, &response);
                    response
                
            },
            ButtonStyle::Primary => {
                // Primary 버튼 스타일도 유사하게 처리
                let accent_color = self.default_style.map_or(
                    egui::Color32::from_rgb(37, 99, 235), 
                    |s| s.accent
                );
                
                let button = egui::Button::new({
                    let text = format!("{:?}", self.icon);
                    egui::RichText::new(text).strong()
                })
                .fill(accent_color);
                
                ui.add(button)
            },
            ButtonStyle::Secondary => {
                // Secondary 버튼 스타일도 유사하게 처리
                let bg_color = self.default_style.map_or(
                    egui::Color32::from_rgb(75, 85, 99), 
                    |s| s.selected
                );
                
                let button = egui::Button::new(format!("{:?}", self.icon))
                .fill(bg_color);
                
                ui.add(button)
            },
        };
        let input=self.clone();
        // 툴팁 추가
        if let Some(tooltip_text) = self.tooltip {
            response = response.on_hover_text(tooltip_text);
        }
    apply_interactive_styles(input,ui, &response);    
        response
    }
    pub fn size(mut self, size: egui::Vec2) -> Self {
        self.size = size;
        self
    }
    
    pub fn tint(mut self, color: egui::Color32) -> Self {
        self.tint = Some(color);
        self
    }
    
    pub fn selected(mut self, selected: bool) -> Self {
        self.selected = selected;
        self
    }
    
    pub fn tooltip(mut self, text: impl Into<String>) -> Self {
        self.tooltip = Some(text.into());
        self
    }
    // 호버/클릭 상태에 따라 스타일 적용하는 헬퍼 메서드

        
}
pub trait TapPage {
    fn new(title: &str) -> Self where Self: Sized;
    fn add(&mut self, item: &str);
    fn render(&mut self, ui: &mut egui::Ui,ctx: &egui::Context);
    fn clone_page(&self) -> Box<dyn TapPage>; // Clone 대신 사용
    fn activate(&mut self);
}

pub struct ToggleController {
    selected: Vec<bool>,
    buttons: Vec<IconButton>,
    callbacks: Vec<Option<Box<dyn Fn()+ 'static>>>, 
    pages: Vec<Option<Rc<RefCell<Box<dyn TapPage>>>>>, // TapPage 트레잇 객체 저장
    index:usize,
    removed:Vec<usize>,
} 
impl ToggleController {
    pub fn new() -> Self {
        let size=0;
        Self {
            selected: vec![false; size],
            buttons: vec![],
            callbacks: Vec::new(),
            pages: vec![], // 페이지 벡터 초기화
            index:0,
            removed:vec![],
        }
    }
    pub fn add<F,T>(&mut self, newbutton: IconButton,callback: Option<F>, page: Option<Rc<RefCell<Box<dyn TapPage>>>>)->usize 
    where 
    F: Fn() + 'static,
    T: TapPage + 'static
    {
        let boxed_callback = callback.map(|f| Box::new(f) as Box<dyn Fn()+ 'static>);
       
        if self.buttons.len()>self.index{
            self.removed.retain(|&x| x != self.index);
            self.selected[self.index]=false;
            self.buttons[self.index]=newbutton;
            self.callbacks[self.index]=boxed_callback;
            self.pages[self.index] = page; // 페이지 업데이트
        }else{
            self.buttons.push(newbutton);
            self.selected.push(false);
            self.callbacks.push(boxed_callback);
            self.pages.push(page); // 새 페이지 추가
            self.index=self.buttons.len();
            
        }
        self.index.clone()
    }
    pub fn remove(&mut self, index:usize) {
        self.removed.push(index);
        self.index=index;
    }
    fn call_toggle(&mut self,id:usize,ui: &mut egui::Ui,ctx: &egui::Context){
        if !self.removed.contains(&id) && self.buttons.len()>id {
        for i in 0..self.selected.len() {
            self.selected[i] = false;
            self.buttons[i]=self.buttons[i].clone().with_style(&UiStyle::deep_navy(1));
        
        
        }
        self.selected[id]=true;
        self.buttons[id]=self.buttons[id].clone().with_style(&UiStyle::bright_blue());
        
        }
    }
    pub fn update_page(&mut self, ui: &mut egui::Ui, ctx: &egui::Context) {
        if let Some(selected_idx) = self.selected.iter().position(|&selected| selected) {
            if !self.removed.contains(&selected_idx) {
                if let Some(page_rc) = &self.pages[selected_idx] {
                    // try_borrow_mut는 Result를 반환
                    if let Ok(mut page) = page_rc.try_borrow_mut() {
                        page.activate();
                    } else {
                        // 이미 가변 대여 중인 경우 처리
                        println!("페이지가 이미 가변 대여 중입니다.");
                    }
                }
            }
        }
    }

    
    fn show_button(&mut self, id: usize, ui: &mut egui::Ui,ctx:&egui::Context ) -> Option<egui::Response> 
    {
        // 유효한 ID인지 먼저 확인

        if id < self.buttons.len() && !self.removed.contains(&id) {
            // 현재 선택 상태를 버튼에 반영
            let button = self.buttons[id].clone().selected(self.selected[id]);
            // 버튼 렌더링 및 응답 가져오기
            let response = button.show(ui);
            
            // 클릭 이벤트 처리
            if response.clicked() {
                self.call_toggle(id,ui,ctx);
               // println!("{:?}",self.selected);
                            // 외부에서 제공된 콜백 실행
                //let callback=&self.callbacks[id];
            if let Some(callback) = &self.callbacks[id] {
                callback(); 
            }
            }
            
            Some(response)
        } else {
            // 유효하지 않은 ID에 대해 None 반환
            None
        }
    }
    pub fn show(&mut self,  ui: &mut egui::Ui,ctx:&egui::Context){
        for index in 0 .. self.buttons.len(){
            if !self.removed.contains(&index){
                let _ = self.show_button(index,ui,ctx);
            }
        }
    }
}


[ui_styles.rs]
use Rusty_egui::egui::Color32;
use std::default::Default;



#[derive(Clone, Copy, Debug)]
pub struct UiStyle {
    pub background: Color32,     // 기본 배경색
    pub selected: Color32,       // 선택된 요소 배경색
    pub accent: Color32,         // 강조색 (버튼 등)
    pub text: Color32,           // 텍스트 색상
    pub border: Color32,         // 테두리 색상
    pub hover: Color32,          // 호버 효과 색상
}

impl UiStyle {
    // 이미지에 보이는 스타일의 프리셋
    pub fn deep_navy(textflag: i8) -> Self {
        if textflag == 1 {
            Self {
                background: Color32::from_rgb(15, 20, 28),   // 매우 어두운 네이비 배경
                selected: Color32::from_rgb(28, 36, 48),     // 선택 영역용 약간 밝은 색상
                accent: Color32::from_rgb(59, 110, 194),     // 파란색 강조
                text: Color32::WHITE,                        // 흰색 텍스트
                border: Color32::from_rgb(35, 40, 50),       // 테두리
                hover: Color32::from_rgb(40, 50, 65)         // 호버 효과
                
            }
        } else if textflag == 2 {
            Self {
                background: Color32::from_rgb(15, 20, 28),   // 매우 어두운 네이비 배경
                selected: Color32::from_rgb(28, 36, 48),     // 선택 영역용 약간 밝은 색상
                accent: Color32::from_rgb(59, 110, 194),     // 파란색 강조
                text: Color32::from_rgb(163, 184, 204),      // 파스텔 블루 텍스트
                border: Color32::from_rgb(35, 40, 50),       // 테두리
                hover: Color32::from_rgb(40, 50, 65)         // 호버 효과
            }
        } else {
            // 기본값 (textflag가 1이나 2가 아닌 경우)
            Self {
                background: Color32::from_rgb(15, 20, 28),
                selected: Color32::from_rgb(28, 36, 48),
                accent: Color32::from_rgb(59, 110, 194),
                text: Color32::WHITE,
                border: Color32::from_rgb(35, 40, 50),
                hover: Color32::from_rgb(40, 50, 65)
            }
        }
    }

    pub fn dark_blue() -> Self {
        Self {
            background: Color32::from_rgb(18, 22, 32),
            selected: Color32::from_rgb(25, 34, 43),
            accent: Color32::from_rgb(59, 110, 194),
            text: Color32::WHITE,
            border: Color32::WHITE,
            hover: Color32::from_rgb(45, 55, 70),
        }
    }
        // 밝은 파란색 테마
    pub fn bright_blue() -> Self {
        Self {
            background: Color32::from_rgb(59, 110, 194),
            selected: Color32::from_rgb(75, 130, 215),  // 조금 더 밝은 파란색
            accent: Color32::from_rgb(255, 255, 255),   // 흰색 강조
            text: Color32::WHITE,
            border: Color32::from_rgb(40, 80, 150),     // 어두운 파란색 테두리
            hover: Color32::from_rgb(80, 140, 230),     // 호버 시 더 밝은 파란색
        }
    }
    pub fn debug() -> Self {
        Self {
            background: Color32::from_rgb(0, 0, 0),
            selected: Color32::from_rgb(150, 150, 150),  // 조금 더 밝은 파란색
            accent: Color32::from_rgb(255, 255, 255),   // 흰색 강조
            text: Color32::WHITE,
            border: Color32::from_rgb(40, 40, 40),     // 어두운 파란색 테두리
            hover: Color32::from_rgb(150, 150, 150),     // 호버 시 더 밝은 파란색
        }
    }
}
pub trait ContextStyle {
    fn apply_style(&self, style: &UiStyle);
}

impl ContextStyle for Rusty_egui::egui::Context {
    fn apply_style(&self, style: &UiStyle)   {
        let _ = &self.style_mut(|ctx_style| {
            ctx_style.visuals.panel_fill = style.background;
            ctx_style.visuals.window_fill = style.background;
            ctx_style.visuals.faint_bg_color = style.selected;
            ctx_style.visuals.widgets.active.bg_fill = style.accent;
            ctx_style.visuals.widgets.hovered.bg_fill = style.hover;
            ctx_style.visuals.override_text_color = Some(style.text);
            ctx_style.visuals.window_stroke = Rusty_egui::egui::Stroke::new(1.0, style.border);
        });

    }
}

pub trait WidgetStyle {
    fn apply_style(self, style: &UiStyle) -> Self;
}

// egui 라이브러리의 타입에 우리 트레이트를 구현
impl WidgetStyle for Rusty_egui::egui::TopBottomPanel {
    fn apply_style(self, style: &UiStyle) -> Self  {
        // 기존 타입을 확장하는 구현
        self.frame(Rusty_egui::egui::Frame::default()
            .fill(style.background)
            .stroke(Rusty_egui::egui::Stroke::new(1.0, style.border)))
        
    }
}
impl <'a> WidgetStyle for Rusty_egui::egui::Button<'a> {
    fn apply_style(self, style: &UiStyle) -> Self{
        // 기존 타입을 확장하는 구현
        self.fill(style.background)
            .stroke(Rusty_egui::egui::Stroke::new(1.0, style.border))
        
    }
}
impl WidgetStyle for Rusty_egui::egui::CentralPanel {
    fn apply_style(self, style: &UiStyle) -> Self  {
        // 기존 타입을 확장하는 구현
        self.frame(Rusty_egui::egui::Frame::default()
            .fill(style.background)
            .stroke(Rusty_egui::egui::Stroke::new(1.0, style.border)))
        
    }
}

[app.rs]
use Rusty_egui::eframe;
use Rusty_egui::egui;
use Rusty_egui::eframe::{App, CreationContext};
use crate::Frontend::Pages::login::{LoginPage,MakeAccountPage};
use crate::Frontend::Pages::dashboard::MainPage;
pub enum PageState {
    LOGIN,
    MAIN,
    FILE,
    MONITER,
    MAKEACCOUNT,
}

pub trait Page{
    fn run(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame)->PageState;
    // 추가로 유용한 메서드들:
    fn _name(&self) -> &str;  // 페이지 이름 반환
    fn _initialize(&mut self);  // 페이지 진입 시 초기화
    fn _cleanup(&mut self);  // 페이지 나갈 때 정리
}


pub struct MyApp {
    Login :Box<dyn Page>,
    Main :Box<dyn Page>,
    File :Box<dyn Page>,
    Moniter :Box<dyn Page>,
    MakeAccountPage : Box<dyn Page>,
    State : PageState,

    

}

impl MyApp  {
    pub fn new(_cc: &CreationContext) -> Self {
        Rusty_egui::replace_fonts(&_cc.egui_ctx);
        Self {
            Login: Box::new(LoginPage::new("Login")),
            Main: Box::new(MainPage::new(&_cc.egui_ctx,"Main")),
            File: Box::new(LoginPage::new("File")),
            Moniter: Box::new(LoginPage::new("Moniter")),
            MakeAccountPage: Box::new(MakeAccountPage::new("MakeAccount")),
            State: PageState::LOGIN,
        }
    }
}


//run(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame)
// 애플리케이션 업데이트 구현
impl App for MyApp {
    fn update(&mut self, ctx: &egui::Context, frame: &mut eframe::Frame) {


        match self.State {
            PageState::LOGIN => {
                ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(500.0, 350.0)));
                let nstate=self.Login.run( ctx, frame);
                self.State = nstate;
            }
            PageState::MAIN => {
                ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(1500.0, 900.0)));
                let nstate: PageState=self.Main.run( ctx, frame);
                self.State = nstate;
            }
            PageState::FILE => {
                //self.File.run();
            }
            PageState::MONITER => {
                //self.Moniter.run();
            }
            PageState::MAKEACCOUNT => {
                ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(850.0, 450.0)));
                let nstate= self.MakeAccountPage.run( ctx, frame);
                self.State = nstate;
            }
        }


    }
}

pub fn run_ui(){
    Rusty_egui::fix_vul_lib();
    // 로거 설정 (선택 사항)
    env_logger::init();

    // 네이티브 옵션 설정
    let options = eframe::NativeOptions {
        viewport : egui::ViewportBuilder::default(),
        
        vsync :true,
        centered: true,
        ..Default::default()
    };

    // 애플리케이션 실행
    let _ = eframe::run_native(
        "test",
        options,
        Box::new(|cc| Ok(Box::new(MyApp::new(cc)))),
    );
}

[dashboard.rs]
use crate::Frontend::app::{Page, PageState};
use Rusty_egui::egui::UiBuilder;
use crate::Frontend::Utility::ui_styles::UiStyle;
use Rusty_egui::egui;
use Rusty_egui::eframe;
use crate::Frontend::Utility::ui_styles::{ContextStyle, WidgetStyle};
use Rusty_egui::egui::Rect;
use usvg;
use resvg;
use egui::ColorImage;
use crate::Frontend::Utility::icon_loader::{IconButton,Icon,ButtonStyle,ToggleController,TapPage};
use Rusty_egui::image::{ImageBuffer, Rgba};
use tiny_skia;
use std::rc::Rc;
use std::cell::RefCell;
const LOCK_ICON: &[u8] = include_bytes!("icon/lock.svg");
const SETTINGS_ICON: &[u8] = include_bytes!("icon/setting.svg");
const PLAY_ICON: &[u8] = include_bytes!("icon/Play Arrow.svg");
const BACK_ICON: &[u8] = include_bytes!("icon/back.svg");
const FORWARD_ICON: &[u8] = include_bytes!("icon/Forward.svg");
use std::collections::HashMap;


struct FILEINFO{
    name: String,
    size: String,
    date: String,
    owner: String,
    status: String,
}
struct FileData{
    files: FILEINFO,
    index: usize,
}
struct Filesystem{
    file_list: Vec<FileData>,
    current_index: usize,
}
impl Filesystem{
    fn new()->Self{
        Self{
            file_list: Vec::new(),
            current_index: 0,
        }
    }
    fn add_file(&mut self,mut file: FileData){
        self.current_index=self.current_index+1;
        file.index=self.current_index;
        self.file_list.push(file);
    }
    fn get_file(&self, index: usize)->Option<&FileData>{
        if index>=self.current_index{
            print!("Index out of range");
            None

        }else{
            Some(&self.file_list[index])}
    }
    fn get_current_file(&self)->&FileData{
        &self.file_list[self.current_index]
    }
    fn get_current_index(&self)->usize{
        self.current_index
    }
}


fn load_svg_icon(ctx: &egui::Context, svg_bytes: &[u8]) -> egui::TextureHandle {
    // SVG를 ColorImage로 변환
    let image = load_svg_as_color_image(svg_bytes);
    
    // ColorImage는 ImageData로 변환 가능
    ctx.load_texture(
        "icon",
        image,
        egui::TextureOptions::default()
    )
}
fn _debug_save_color_image_as_png(color_image: &ColorImage, path: &str) {
    let width = color_image.width();
    let height = color_image.height();

    let mut img_buf = ImageBuffer::new(width as u32, height as u32);

    for y in 0..height {
        for x in 0..width {
            // ColorImage는 (r, g, b, a) 각 8비트
            let c = color_image[(x, y)];
            let pixel = Rgba([c.r(), c.g(), c.b(), c.a()]);
            img_buf.put_pixel(x as u32, y as u32, pixel);
        }
    }

    // 실제로 PNG로 저장
    img_buf
        .save(path)
        .unwrap_or_else(|e| eprintln!("PNG 파일 저장 실패: {}", e));
}
fn load_svg_as_color_image(svg_bytes: &[u8]) -> egui::ColorImage {
    use usvg::{Tree, Options};
    use resvg;

    let options = Options::default();
    let rtree = Tree::from_data(svg_bytes, &options).expect("SVG 파싱 실패");

    let pixmap_size = rtree.size().to_int_size();
    let (w, h) = (pixmap_size.width() as u32, pixmap_size.height() as u32);

    let mut pixmap = tiny_skia::Pixmap::new(w, h).unwrap();

    // pixmap.as_mut() : Option<PixmapMut<'_>>
    // 잘못된 예 (직접 as_mut() 결과를 넣거나...)
    resvg::render(&rtree, tiny_skia::Transform::default(),&mut pixmap.as_mut());
    // ↑ 여기서 타입 불일치: 
    //   expected `&mut PixmapMut`, found `Option<PixmapMut>`

    let rgba_data = pixmap.data();
    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], rgba_data)
}
#[derive(Clone)]
struct ExplorerPage{
    _name: String,
    _id_field: String,  // 이렇게 필드 추가
    draw : bool,
}
impl TapPage for ExplorerPage{
    fn new(input:&str) -> Self {
        Self {
            _name: input.to_string(),
            _id_field: String::new(),
            draw:false,

        }
    }
    fn add(&mut self,item: &str){

    }

    fn render(&mut self, ui: &mut egui::Ui,ctx: &egui::Context) {
        if self.draw{
            if IconButton::new(ctx, Icon::FOLDER2, ButtonStyle::Explorer)
            .size(egui::vec2(40.0, 40.0))
            .tooltip("file1")
            .show(ui).clicked(){
                println!("File1 Clicked");
            }
        }
    }
    fn clone_page(&self) -> Box<dyn TapPage> {
        Box::new(Self::clone(self))
    }
    fn activate(&mut self) {
        self.draw=true;
    }
    
}
impl ExplorerPage{
    fn file(&mut self,ctx:&egui::Context,ui: &mut egui::Ui){
        if self.draw{
            if IconButton::new(ctx, Icon::FOLDER2, ButtonStyle::Explorer)
            .size(egui::vec2(40.0, 40.0))
            .tooltip("file1")
            .show(ui).clicked(){
                println!("File1 Clicked");

            }
            self.draw=false;
        }
    }
}
#[derive(Clone)]
struct Basepage{
    _name: String,
    _id_field: String,  // 이렇게 필드 추가
    draw : bool,
}
impl TapPage for Basepage{
    fn new(input:&str) -> Self {
        Self {
            _name: input.to_string(),
            _id_field: String::new(),
            draw:false,
        }
    }
    fn add(&mut self,item: &str){

    }

    fn render(&mut self, ui: &mut egui::Ui,ctx: &egui::Context) {
        if self.draw{
            ui.label("Base Page");
            self.draw=false;
        }
        
    }
    fn clone_page(&self) -> Box<dyn TapPage> {
        Box::new(Self::clone(self))
    }
    fn activate(&mut self) {
        self.draw=true;
    }
}

struct AreaStructure {
    window: Rect,
    top_layer: UiBuilder,
    left_top: UiBuilder,  // 이렇게 필드 추가
    left_bottom: UiBuilder,
    right_top: UiBuilder,
    right_bottom: UiBuilder,
    bottom_layer: UiBuilder,
}

#[derive(PartialEq, Clone, Copy)]
enum LeftTabState {
    Files,
    Favorites,
    Recent,
    None,
}

impl AreaStructure {
    pub fn new() -> Self {
        Self {
            window: Rect::from_min_size(egui::Pos2::new(0.0, 0.0), egui::vec2(500.0, 350.0)),
            top_layer: UiBuilder::default(),
            left_top: UiBuilder::default(),
            left_bottom: UiBuilder::default(),
            right_top: UiBuilder::default(),
            right_bottom: UiBuilder::default(),
            bottom_layer: UiBuilder::default(),
        }
    }
    pub fn _initialize(&mut self, window_rect_no_margin: Rect) {

        let margin:f32 = 5.0;
        let  window_rect = Rect::from_min_size(
            egui::pos2(window_rect_no_margin.min.x + margin, window_rect_no_margin.min.y + margin),
            egui::vec2(window_rect_no_margin.width() - margin , window_rect_no_margin.height() - margin )
        );
        // 비율 상수들
        let top_layer_ratio = 0.05;      // 상단 영역 높이 비율
        let bottom_layer_ratio = 0.1;   // 하단 영역 높이 비율
        let left_side_ratio = 0.2;      // 좌측 영역 너비 비율
        
        let left_top_ratio = 0.5;       // 좌측 상단 높이 비율 (좌측 영역 내에서)
        let left_bottom_ratio = 0.5;    // 좌측 하단 높이 비율
        
        let right_top_ratio = 0.2;      // 우측 상단 높이 비율 (우측 영역 내에서)
        let right_bottom_ratio = 0.9;   // 우측 하단 높이 비율
        
        // 전체 창 크기 저장
        self.window = window_rect;
        
        let width = window_rect.width();
        let height = window_rect.height();
        
        // 상단 레이어
        let top_height = height * top_layer_ratio;
        let top_rect = Rect::from_min_size(
            window_rect.min,
            egui::vec2(width, top_height)
        );
        self.top_layer = UiBuilder::new().max_rect(top_rect);
        
        // 하단 레이어
        let bottom_height = height * bottom_layer_ratio;
        let bottom_rect = Rect::from_min_size(
            egui::pos2(window_rect.min.x, window_rect.max.y - bottom_height),
            egui::vec2(width, bottom_height)
        );
        self.bottom_layer = UiBuilder::new().max_rect(bottom_rect);
        
        // 중앙 영역
        let middle_height = height - top_height - bottom_height;
        let middle_min_y = window_rect.min.y + top_height;
        
        // 좌우 분할
        let left_width = width * left_side_ratio;
        let right_width = width - left_width;
        
        // 좌측 상단
        let left_top_height = middle_height * left_top_ratio;
        let left_top_rect = Rect::from_min_size(
            egui::pos2(window_rect.min.x, middle_min_y),
            egui::vec2(left_width, left_top_height)
        );
        self.left_top = UiBuilder::new().max_rect(left_top_rect);
        
        // 좌측 하단
        let left_bottom_rect = Rect::from_min_size(
            egui::pos2(window_rect.min.x, middle_min_y + left_top_height),
            egui::vec2(left_width, middle_height * left_bottom_ratio)
        );
        self.left_bottom = UiBuilder::new().max_rect(left_bottom_rect);
        
        // 우측 상단
        let right_top_height = middle_height * right_top_ratio;
        let right_top_rect = Rect::from_min_size(
            egui::pos2(window_rect.min.x + left_width, middle_min_y),
            egui::vec2(right_width, right_top_height)
        );
        self.right_top = UiBuilder::new().max_rect(right_top_rect);
        
        // 우측 하단
        let right_bottom_rect = Rect::from_min_size(
            egui::pos2(window_rect.min.x + left_width, middle_min_y + right_top_height),
            egui::vec2(right_width, middle_height * right_bottom_ratio)
        );
        self.right_bottom = UiBuilder::new().max_rect(right_bottom_rect);
    }

}

pub struct MainPage {
    _name: String,
    _id_field: String,  // 이렇게 필드 추가
    area: AreaStructure,
    //lock.svg, setting.svg Play Arrow Skip Next Stop_music Skip Previous Forward back
    lock_icon: egui::TextureHandle,
    settings_icon: egui::TextureHandle,
    back_icon: egui::TextureHandle,
    play_icon: egui::TextureHandle,
    forward_icon: egui::TextureHandle,
    current_left_tab: LeftTabState,
    toggle_set:ToggleController,
    explorer: Option<Rc<RefCell<Box<dyn TapPage>>>>,
}
impl MainPage {
    pub fn new(ctx: &egui::Context, name: &str) -> Self 

    {
        // SVG 아이콘 로딩
        let lock_icon = load_svg_icon(ctx, LOCK_ICON);
        let settings_icon = load_svg_icon(ctx, SETTINGS_ICON);
        let play_icon = load_svg_icon(ctx, PLAY_ICON);
        let back_icon = load_svg_icon(ctx, BACK_ICON);
        let forward_icon = load_svg_icon(ctx, FORWARD_ICON);
        let current_left_tab = LeftTabState::None;
        let mut toggle=ToggleController::new();
        toggle.add::<fn(),Basepage>(
            IconButton::new(ctx, Icon::CLOUD_WITH_BK, ButtonStyle::Menu)
            .size(egui::vec2(24.0, 24.0))
            .with_style(&UiStyle::deep_navy(1))  
            .with_hover_style(&UiStyle::deep_navy(1))
            .with_click_style(&UiStyle::bright_blue())
            .tooltip("Data Cloud"),
            None as Option<fn()>,
            Some(Rc::new(RefCell::new(Box::new(Basepage::new("Data Cloud")) as Box<dyn TapPage>)))
        );
        toggle.add::<fn(),Basepage>(IconButton::new(ctx, Icon::DOCKER, ButtonStyle::Menu)
        .size(egui::vec2(24.0, 24.0))
        .with_style(&UiStyle::deep_navy(1))  
        .with_hover_style(&UiStyle::deep_navy(1))
        .with_click_style(&UiStyle::bright_blue())
        .tooltip("Docker Management"),Some(|| println!("Docker Clicked")),Some(Rc::new(RefCell::new(Box::new(Basepage::new("Docker Management")) as Box<dyn TapPage>))));
        toggle.add::<fn(),Basepage>(IconButton::new(ctx, Icon::CONTROLBAR, ButtonStyle::Menu)
        .size(egui::vec2(24.0, 24.0))
        .with_style(&UiStyle::deep_navy(1))  
        .with_hover_style(&UiStyle::deep_navy(1))
        .with_click_style(&UiStyle::bright_blue())
        .tooltip("Control Panel"),None as Option<fn()>,Some(Rc::new(RefCell::new(Box::new(Basepage::new("Control Panel")) as Box<dyn TapPage>))));
        toggle.add::<fn(),Basepage>(IconButton::new(ctx, Icon::FILE, ButtonStyle::Menu)
        .size(egui::vec2(24.0, 24.0))
        .with_style(&UiStyle::deep_navy(1))  
        .with_hover_style(&UiStyle::deep_navy(1))
        .with_click_style(&UiStyle::bright_blue())
        .tooltip("Terminal"),None as Option<fn()>,Some(Rc::new(RefCell::new(Box::new(Basepage::new("Terminal")) as Box<dyn TapPage>))));
        let subpage=Some(Rc::new(RefCell::new(Box::new(ExplorerPage::new("Terminal")) as Box<dyn TapPage>)));
        toggle.add::<fn(),Basepage>(IconButton::new(ctx, Icon::FOLDER2, ButtonStyle::Menu)
        .size(egui::vec2(24.0, 24.0))
        .with_style(&UiStyle::deep_navy(1))  
        .with_hover_style(&UiStyle::deep_navy(1))
        .with_click_style(&UiStyle::bright_blue())
        .tooltip("Explorer"),None as Option<fn()>,subpage.clone());

        
        Self {
            _name: name.to_string(),
            _id_field: String::new(),
            area: AreaStructure::new(),
            lock_icon,
            settings_icon,
            play_icon,
            back_icon,
            forward_icon,
            current_left_tab,
            toggle_set:toggle,
            explorer: subpage.clone(),          
        }
    }
    fn render_top_layer(&mut self, ui: &mut egui::Ui,returnV:&mut PageState) {
        *returnV=PageState::MAIN;
        ui.horizontal(|ui| {
            // 왼쪽 영역: 뒤로가기/앞으로가기 버튼
            let back_button = egui::ImageButton::new(
                egui::load::SizedTexture::new(self.back_icon.id(), egui::vec2(20.0, 20.0))
            ).frame(true);  // 프레임(배경) 추가
            if ui.add(back_button).clicked() {
                // 뒤로가기 기능
            }
            let forward_button = egui::ImageButton::new(
                egui::load::SizedTexture::new(self.forward_icon.id(), egui::vec2(20.0, 20.0))
            ).frame(true);  // 프레임(배경) 추가
            if ui.add(forward_button).clicked() {
                // 뒤로가기 기능
            }
            
            // 중앙 영역: 앱 제목
            ui.with_layout(egui::Layout::centered_and_justified(egui::Direction::LeftToRight), |ui| {
                
            });
            
            // 오른쪽 영역: 아이콘들
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
            

                let lock_button = egui::ImageButton::new(
                    egui::load::SizedTexture::new(self.lock_icon.id(), egui::vec2(20.0, 20.0))
                ).frame(true);  // 프레임(배경) 추가
                if ui.add(lock_button).clicked() {
                    *returnV=PageState::LOGIN;
                    //잠금 기능
                }
                let settings_button = egui::ImageButton::new(
                    egui::load::SizedTexture::new(self.settings_icon.id(), egui::vec2(20.0, 20.0))
                ).frame(true);  // 프레임(배경) 추가
                if ui.add(settings_button).clicked() {
                    // 설정 기능
                }

            });
        });
    }
    //Plain,     // 프레임 없음
    //Framed,    // 프레임 있음
    //Menu,      // 메뉴 항목 스타일
    //Primary,   // 주요 액션 버튼
    //Secondary, // 보조 액션 버튼
    fn render_left_top(&mut self, ui : &mut egui::Ui,ctx: &egui::Context) {
        ui.vertical_centered(|ui| {
            ui.label("Memu");
            ui.separator();        
            ui.vertical_centered(|ui| {
            
            self.toggle_set.show(ui,ctx);
            self.toggle_set.update_page(ui,ctx);
            });
        
        ui.vertical_centered(|ui| {
            

        });
        ui.separator();
            
            // 현재 선택된 탭 내용 표시
            match self.current_left_tab {
                LeftTabState::Files => {
                    ui.label("파일 목록");
                    // 파일 목록 UI 구현
                },
                LeftTabState::Favorites => {
                    ui.label("즐겨찾기 목록");
                    // 즐겨찾기 목록 UI 구현
                },
                LeftTabState::Recent => {
                    ui.label("최근 파일 목록");
                    // 최근 파일 목록 UI 구현
                },
                LeftTabState::None => {
                    
                }
            }
        });
    }
    
    
    fn render_left_bottom(&mut self, ui: &mut egui::Ui) {
        // 좌측 하단 UI 코드
        ui.label("좌측 하단");
    }

    fn render_bottom_layer(&mut self, ui: &mut egui::Ui) {
        // 상단 레이어 UI 코드
        ui.label("하단레이어");
    }
    
    fn render_right_top(&mut self, ui: &mut egui::Ui,ctx : &egui::Context) {
        // 우측 상단 UI 코드
        ui.label("우측 상단");
    }
    
    fn render_right_bottom(&mut self, ui: &mut egui::Ui,ctx : &egui::Context) {

        if let Some(rc_page) = & self.explorer {  // Option 언래핑
            // RefCell에서 내용물 빌리기
            let mut page_ref = rc_page.borrow_mut();
            // 이제 page_ref로 render 메서드 호출
            page_ref.render(ui, ctx);
        }
    }
}






impl Page  for MainPage {

    fn run(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame)->PageState {
        let _ = &ctx.apply_style(&UiStyle::deep_navy(2));
        let mut returnV=PageState::MAIN;
        egui::CentralPanel::default()
        .frame(egui::Frame {
            outer_margin: Rusty_egui::egui::Margin::same(25.0),
            inner_margin: Rusty_egui::egui::Margin::same(25.0),
        ..Default::default()
        }).apply_style(&UiStyle::dark_blue()).show(ctx, |ui| {
            let full_rect = ui.max_rect();
            self.area._initialize(full_rect);

            ui.allocate_new_ui(self.area.top_layer.clone(), |ui| {
                self.render_top_layer(ui,&mut returnV);
            });
            ui.allocate_new_ui(self.area.left_top.clone(), |ui| {
                self.render_left_top(ui,ctx);
            });
            ui.allocate_new_ui(self.area.left_bottom.clone(), |ui| {
                self.render_left_bottom(ui);
            });
            ui.allocate_new_ui(self.area.right_top.clone(), |ui| {
                self.render_right_top(ui,ctx);
            });
            ui.allocate_new_ui(self.area.right_bottom.clone(), |ui| {
                self.render_right_bottom(ui,ctx);
            });
            ui.allocate_new_ui(self.area.bottom_layer.clone(), |ui| {
                self.render_bottom_layer(ui);
            });
       
       

    }
    );
    returnV
}    
    
    
    fn _name(&self) -> &str {
        &self._name
    }
    fn _initialize(&mut self) {
        println!("{} 페이지에 진입했습니다.", self._name);
    }
    fn _cleanup(&mut self) {
        println!("{} 페이지를 나갑니다.", self._name);
    }
    
}
//lock.svg, setting.svg Play Arrow Skip Next Stop_music Skip Previous Forward back

[login.rs]
use crate::Frontend::app::{Page, PageState};
use Rusty_egui::egui::UiBuilder;
use Rusty_egui::egui;
use Rusty_egui::eframe;
use crate::Frontend::Utility::ui_styles::{ContextStyle, WidgetStyle, UiStyle};


pub struct MakeAccountPage{
    _name: String,
    id_field: String,  // 이렇게 필드 추가
    password_field: String,
    password_check_field: String,
    name_field: String,
    reason_field: String,
    job_field: String,
    email_field: String,
    phone_field: String,
    region_field: String,
    religion_field : String,
}
impl MakeAccountPage {
    pub fn new(name: &str) -> Self {
        Self {
            _name: name.to_string(),
            id_field: String::new(),
            password_field: String::new(),
            password_check_field: String::new(),
            name_field: String::new(),
            reason_field: String::new(),
            job_field: String::new(),
            email_field: String::new(),
            phone_field: String::new(),
            region_field: String::new(),
            religion_field: String::new(),
        }
    }
}
impl Page for MakeAccountPage {
    fn run(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) -> PageState {
        let mut return_v = PageState::MAKEACCOUNT;
        let _ = &ctx.apply_style(&UiStyle::deep_navy(2));

        egui::CentralPanel::default()
            .frame(egui::Frame {
                outer_margin: Rusty_egui::egui::Margin::same(0.0),
                inner_margin: Rusty_egui::egui::Margin::same(0.0),
            ..Default::default()
            })
            .apply_style(&UiStyle::dark_blue()) // 필요시
            .show(ctx, |ui| {
                // 전체 패널의 위치/크기
                let full_rect = ui.max_rect();
                let width = full_rect.width();
                let height = full_rect.height();

                // ─────────────────────────────────────────────────────────
                // 1) 상단 10% rect
                let top_h = height * 0.20; // 10%
                let top_rect = egui::Rect::from_min_size(
                    full_rect.min,
                    egui::vec2(width, top_h),
                );

                // 2) 하단 10% rect
                let bottom_h = height * 0.20; // 10%
                let bottom_rect = egui::Rect::from_min_size(
                    // y좌표는 전체 하단에서 bottom_h만큼 뺀 위치
                    egui::pos2(full_rect.min.x, full_rect.max.y - bottom_h),
                    egui::vec2(width, bottom_h),
                );
                let small_rect = egui::Rect::from_min_max(
                    egui::pos2(full_rect.min.x,  full_rect.min.y + top_h ),
                    egui::pos2( full_rect.min.x + width * 0.2, full_rect.max.y - bottom_h),
                );
                // 3) 중간 80% rect (상단/하단 사이)
                //    좌우로도 15%씩 제외하여 가운데 70%만 사용
                let middle_rect = egui::Rect::from_min_max(
                    egui::pos2(
                        full_rect.min.x + width * 0.2,         // 왼쪽 15%
                        full_rect.min.y + top_h                 // 위에서 10% 내려온 지점
                    ),
                    egui::pos2(
                        full_rect.max.x ,         
                        full_rect.max.y - bottom_h              // 아래에서 10% 위 지점
                    ),
                );

                // ─────────────────────────────────────────────────────────
                // (A) 상단 10%: 제목/설명
                ui.allocate_new_ui(UiBuilder::new().max_rect(top_rect), |ui| {
                    ui.add_space(20.0);
                    ui.vertical_centered(|ui| {
                        ui.heading("Sign Up");
                        ui.add_space(10.0);
                        ui.label("Create an account to manage your servers efficiently");
                    });
                });

                // (B) 하단 10%: 버튼
                ui.allocate_new_ui(UiBuilder::new().max_rect(bottom_rect), |ui| {
                    ui.vertical_centered(|ui| {
                        if ui
                            .add(egui::Button::new("Sign Up!!").apply_style(&UiStyle::bright_blue()).min_size(egui::vec2(500.0, 30.0)))
                            .clicked()
                        {
                            // 가입 버튼 클릭 시 처리
                            // ex) return_v = PageState::LOGIN;
                            return_v = PageState::LOGIN;
                        }
                    });
                });
                ui.allocate_new_ui(UiBuilder::new().max_rect(small_rect), |ui| {
                    ui.add_space(30.0);
                    egui::Grid::new("small_grid")
                    .num_columns(2)
                    .spacing([10.0, 30.0])
                    .show(ui, |ui| {


                        ui.label("");
                        ui.label("ID");
                        ui.end_row();
                        ui.label("");
                        ui.label("password");
                        ui.end_row();
                        ui.label("");
                        ui.label("이름");
                        ui.end_row();
                        ui.label("");
                        ui.label("직업");
                        ui.end_row();
                        ui.label("");
                        ui.label("거주지");

                    });
                });
                // (C) 중간 80%: 좌우 15% 빼고 남은 영역에서
                ui.allocate_new_ui(UiBuilder::new().max_rect(middle_rect), |ui| {
                    // 1) 첫 줄: 라벨 5개
                    ui.horizontal(|ui| {

                    });

                    ui.add_space(20.0);

                    // 2) 3열 Grid
                    egui::Grid::new("signup_grid")
                        .num_columns(3)
                        .min_col_width(210.0)
                        .spacing([10.0, 30.0])
                        .show(ui, |ui| {
                            // 1행
                            ui.add(
                                egui::TextEdit::singleline(&mut self.id_field)
                                    .hint_text("ID를 입력하세요"),
                            );
                            ui.label("가입 사유");
                            ui.add(
                                egui::TextEdit::singleline(&mut self.reason_field)
                                    .hint_text("가입 사유?"),
                            );
                            ui.end_row();

                            // 2행 (password)
                            let password_input = egui::TextEdit::singleline(&mut self.password_field)
                                .hint_text("Enter your password")
                                .password(true)
                                .desired_width(300.0);
                            ui.add(password_input);

                            ui.label("retype password");
                            let password_check_input =
                                egui::TextEdit::singleline(&mut self.password_check_field)
                                    .hint_text("Retype password")
                                    .password(true)
                                    .desired_width(300.0);
                            ui.add(password_check_input);
                            ui.end_row();

                            // 3행 (이름)
                            ui.add(
                                egui::TextEdit::singleline(&mut self.name_field)
                                    .hint_text("실명을 입력하세요"),
                            );
                            ui.label("이메일");
                            ui.add(
                                egui::TextEdit::singleline(&mut self.email_field)
                                    .hint_text("이메일 주소"),
                            );
                            ui.end_row();

                            // 4행 (직업)
                            ui.add(
                                egui::TextEdit::singleline(&mut self.job_field)
                                    .hint_text("직업을 입력하세요"),
                            );
                            ui.label("전화번호");
                            ui.add(
                                egui::TextEdit::singleline(&mut self.phone_field)
                                    .hint_text("전화번호"),
                            );
                            ui.end_row();

                            // 5행 (거주지)
                            ui.add(
                                egui::TextEdit::singleline(&mut self.region_field)
                                    .hint_text("지역을 입력하세요"),
                            );
                            ui.label("종교");
                            ui.add(
                                egui::TextEdit::singleline(&mut self.religion_field)
                                    .hint_text("종교를 입력하세요"),
                            );
                            ui.end_row();
                        });
                });
            });

        return_v
    }
    
    
    fn _name(&self) -> &str {
        &self._name
    }
    fn _initialize(&mut self) {
        println!("{} 페이지에 진입했습니다.", self._name);
    }
    fn _cleanup(&mut self) {
        println!("{} 페이지를 나갑니다.", self._name);
    }   


}





pub struct LoginPage{
    _name: String,
    _id_field: String,  // 이렇게 필드 추가
    password_field: String,

}
impl LoginPage {
    pub fn new(name: &str) -> Self {
        Self {
            _name: name.to_string(),
            _id_field: String::new(),
            password_field: String::new(),
           
        }
    }
}

impl Page  for LoginPage {

    fn run(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame)->PageState {
        let _ = &ctx.apply_style(&UiStyle::deep_navy(2));
        let mut returnV=PageState::LOGIN;
        egui::CentralPanel::default().apply_style(&UiStyle::dark_blue()).show(ctx, |ui| {
            ui.vertical_centered(|ui| {
            ui.add_space(20.0);
            ui.heading(egui::RichText::new("Access Account").size(32.0));
            ui.label(
                egui::RichText::new("Log in to manage your servers efficiently")
                    .size(16.0)
                    .color(egui::Color32::from_rgba_unmultiplied(180, 180, 180, 200))
            );
            ui.add_space(30.0);
            ui.add_space(20.0);
            let ID_input = egui::TextEdit::singleline(&mut self._id_field)
                .hint_text("Your ID") // 흐릿한 placeholder 텍스트
                .desired_width(300.0);
            ui.add(ID_input);
            ui.add_space(20.0);
            let password_input = egui::TextEdit::singleline(&mut self.password_field)
                .hint_text("Enter your password")
                .password(true) // 비밀번호 마스킹 처리
                .desired_width(300.0);
            ui.add(password_input);
            ui.add_space(20.0);
            if ui.add(egui::Button::new("Log In").apply_style(&UiStyle::bright_blue()).min_size(egui::vec2(300.0, 40.0))).clicked() {
                // 로그인 버튼 클릭 시 실행할 코드
                returnV=PageState::MAIN;
                
            }
            ui.add_space(5.0);
        // 컨테이너 중앙 정렬 시도
        egui::Frame::none()
            .inner_margin(egui::vec2(0.0, 5.0))
            .show(ui, |ui| {
                ui.with_layout(egui::Layout::top_down(egui::Align::Center), |ui| {
                    ui.horizontal(|ui| {
                        ui.add_space(20.0);
                        ui.label("Need to create an account?");
                        let signup_text = egui::RichText::new("Sign Up")
                        .color(egui::Color32::from_rgb(100, 100, 255))
                        .underline();
                    
                    if ui.button(signup_text).clicked() {
                        returnV=PageState::MAKEACCOUNT;
                       // println!("Sign Up 클릭됨!");
                    }
                    });
                });
            });
        });
    }
    );
    returnV
}    
    
    
    fn _name(&self) -> &str {
        &self._name
    }
    fn _initialize(&mut self) {
        println!("{} 페이지에 진입했습니다.", self._name);
    }
    fn _cleanup(&mut self) {
        println!("{} 페이지를 나갑니다.", self._name);
    }
    
}

